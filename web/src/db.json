{"code":["/*\n * @lc app=leetcode.cn id=1 lang=javascript\n *\n * [1] 两数之和\n */\n// @lc code=start\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let sorted = []\n    nums.map((item, index) => {\n        sorted.push([item, index])\n    })\n    sorted.sort((a, b) => {return a[0] - b[0]})\n    let i = 0\n    let j = sorted.length - 1\n    while(true) {\n        if (sorted[i][0] + sorted[j][0] === target) {\n            return [sorted[i][1], sorted[j][1]]\n        } else if (sorted[i][0] + sorted[j][0] > target) {\n            j--\n        } else {\n            i++\n        }\n    }\n};\n// @lc code=end","/*\n * @lc app=leetcode.cn id=2 lang=javascript\n *\n * [2] 两数相加\n */\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n var addTwoNumbers = function(l1, l2) {\n  let head, tail;\n  let carry = 0; // 进位\n  while (l1 || l2) {\n      const num1 = l1 ? l1.val : 0;\n      const num2 = l2 ? l2.val : 0;\n      const sum = num1 + num2 + carry;\n      carry = Math.floor(sum / 10);\n      if (!head) {\n          // 当 res 连表不存在的时候，创建链表以及 head 和 tail 指针\n          head = tail = new ListNode(sum % 10);\n      } else {\n          // 当 res 链表存在的时候，加入到 tail 的 next 位置\n          tail.next = new ListNode(sum % 10);\n          tail = tail.next; \n      }\n      if (l1) {\n          l1 = l1.next;\n      }\n      if (l2) {\n          l2 = l2.next;\n      }\n  }\n  if (carry > 0) {\n      tail.next = new ListNode(carry);\n  }\n  return head;\n};\n// @lc code=end","/*\n * @lc app=leetcode.cn id=3 lang=javascript\n *\n * [3] 无重复字符的最长子串\n */\n// @lc code=start\n/**\n * @param {string} s\n * @return {number}\n */\n/** 滑动窗口双指针 */\nvar lengthOfLongestSubstring = function(s) {\n  if (s === null || s.length === 0) {\n      return 0;\n  }\n  let left = 0, right = 0, res = 0;\n  const set = new Set();\n  for (right; right < s.length; right++) {\n      if (!set.has(s[right])) {\n          set.add(s[right]);\n          res = Math.max(res, set.size);\n      } else {\n          // set 中有重复元素，则不断让 left++ 并删除相同的元素，直至没有重复元素\n          while (set.has(s[right])) {\n              set.delete(s[left]);\n              left++;\n          }\n          set.add(s[right]);\n      }\n  }\n  return res;\n};\n// @lc code=end","/*\n * @lc app=leetcode.cn id=4 lang=javascript\n *\n * [4] 寻找两个正序数组的中位数\n */\n// @lc code=start\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\n var findMedianSortedArrays = function(nums1, nums2) {\n  const m = nums1.length;\n  const n = nums2.length;\n  const totalLength = m + n;\n  if (totalLength % 2 === 1) { // 如果两个数组长度总和为奇数\n      const midIndex = parseInt(totalLength / 2);\n      return getKthElement(nums1, nums2, midIndex + 1);\n  } else { // 如果两个数组长度总和为偶数\n      const midIndex1 = parseInt(totalLength / 2) - 1;\n      const midIndex2 = parseInt(totalLength / 2);\n      const res = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2;\n      return res;\n  }\n};\nconst getKthElement = (nums1, nums2, k) => {\n  const len1 = nums1.length;\n  const len2 = nums2.length;\n  let idx1 = 0; // nums1 数组起始位置指针\n  let idx2 = 0; // nums2 数组起始位置指针\n  let idxK = k;\n  while (true) {\n      if (idx1 === len1) { // 如果一个数组已筛选完成，返回另一个数组中第 k 小的元素\n          return nums2[idx2 + idxK - 1];\n      }\n      if (idx2 === len2) { // 如果一个数组已筛选完成，返回另一个数组中第 k 小的元素\n          return nums1[idx1 + idxK - 1];\n      }\n      if (idxK === 1) { // 如果 k=1，返回两个数组首元素的最小值\n          return Math.min(nums1[idx1], nums2[idx2]);\n      }\n      const newIdx1 = Math.min(idx1 + parseInt(idxK / 2), len1) - 1;\n      const newIdx2 = Math.min(idx2 + parseInt(idxK / 2), len2) - 1;\n      const pivot1 = nums1[newIdx1]; // nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个\n      const pivot2 = nums2[newIdx2]; // nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个\n      // 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个\n      if (pivot1 <= pivot2) { // 过滤掉 nums1 中小于等于 pivot1 的元素，并修改 k 的值以及 nums1 数组起始位置指针\n          idxK = idxK - (newIdx1 - idx1 + 1);\n          idx1 = newIdx1 + 1;\n      } else { // 过滤掉 nums2 中小于等于 pivot2 的元素，并修改 k 的值以及 nums2 数组起始位置指针\n          idxK = idxK - (newIdx2 - idx2 + 1);\n          idx2 = newIdx2 + 1;\n      }\n  }\n};\n// @lc code=end","/*\n * @lc app=leetcode.cn id=5 lang=javascript\n *\n * [5] 最长回文子串\n */\n// @lc code=start\n/**\n * @param {string} s\n * @return {string}\n */\n/** 方法1：动态规划 */\n// 定义 dp[i][j] 表示子串 i～j 是否是回文子串\n// 如果 s[i]，s[j] 相等，则 dp[i][j] 是否为回文串取决于 dp[i+1][j-1] 是否也是回文子串\n// 时间复杂度 O(n^2)，两层循环。空间复杂度 O(n^2)，即动态规划 dp 数组的空间。\nvar longestPalindrome = function(s) {\n  if (!s.length || s.length === 1) {\n      return s;\n  }\n  let res = '';\n  const n = s.length;\n  const dp = Array.from(new Array(n), () => new Array(n).fill(false));\n  for (let i = n - 1; i >= 0; i--) {\n      for (let j = i; j < n; j++) {\n          // j - i < 2表示子串小于等于1也是回文串\n          dp[i][j] = s[i] === s[j] && (j - i < 2 || dp[i+1][j-1]);\n          // 更新最大长度\n          if (dp[i][j] && j - i + 1 > res.length) {\n              res = s.substring(i, j + 1);\n          }\n      }\n  }\n  return res;\n};\n/** 方法2：左右指针 */\n// function longestPalindrome(s) {\n//     let res = '';\n//     for (let i = 0; i < s.length; i++) {\n//         // 寻找长度为奇数的回文子串(以当前元素向两边扩散)\n//         const s1 = palindrome(s, i, i);\n//         // 寻找长度为偶数的回文子串(以s[i],s[i + 1])向两边扩散\n//         const s2 = palindrome(s, i, i + 1);\n//         res = res.length > s1.length ? res : s1;\n//         res = res.length > s2.length ? res : s2;\n//     }\n//     return res;\n// };\n// function palindrome(str, left, right) {\n//     // 左右指针，从 str[left] 和 str[right] 向两边扩散，找到最长回文串\n//     while (left >= 0 && rigiht < str.length && str[left] == str[rigiht]) {\n//         left--;\n//         right++;\n//     }\n//     return str.substr(left + 1, right - left - 1);\n// }\n// @lc code=end"],"name":["两数之和","两数相加","无重复字符的最长子串","寻找两个正序数组的中位数","最长回文子串"],"type":["js","js","js","js","js"],"number":[[0,1],[1,2],[2,3],[3,4],[4,5]],"allTypes":["js"],"questionType":[],"allQuestionTypes":[],"js":[[0,1],[1,2],[2,3],[3,4],[4,5]]}